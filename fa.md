### 2-SAT

#### اثبات درستی

**نمودار تبعات و SCCها:**
1. **ساخت نمودار تبعات:**
   هر بند $(a \lor b)$ می‌تواند به دو تبعه تبدیل شود: $(\neg a \rightarrow b)$ و $(\neg b \rightarrow a)$. این بدان معناست که اگر $a$ نادرست باشد، $b$ باید درست باشد و اگر $b$ نادرست باشد، $a$ باید درست باشد. این دو تبعه را به عنوان یال‌های جهت‌دار در نمودار تبعات رسم می‌کنیم.

2. **یافتن اجزای قوی متصل (SCCها):**
   از الگوریتم‌های kosaraju یا tarjan برای یافتن تمامی SCCها در نمودار استفاده کنید. SCCها زیرگراف‌هایی هستند که در آن‌ها هر جفت گره قابل دسترسی به یکدیگر است.

3. **بررسی قابل رضایت بودن:**
   اگر $x_i$ و $\neg x_i$ در یک SCC باشند، فرمول غیر قابل رضایت است، زیرا به این معناست که $x_i$ و $\neg x_i$ باید همزمان درست باشند که امکان‌پذیر نیست. در غیر این صورت، مقادیر را بر اساس ترتیب توپولوژیکی SCCها اختصاص دهید. این به این معناست که اگر $\neg x_i$ قبل از $x_i$ در ترتیب توپولوژیکی بیاید، $x_i$ باید درست باشد و بالعکس.

**مثال:**
مثال $(x_1 \lor x_2) \land (\neg x_1 \lor x_3) \land (\neg x_2 \lor \neg x_3)$ را در نظر بگیرید:
- ساخت نمودار: 
  - از $(x_1 \lor x_2)$ به $(\neg x_1 \rightarrow x_2)$ و $(\neg x_2 \rightarrow x_1)$ تبدیل می‌شود.
  - از $(\neg x_1 \lor x_3)$ به $(x_1 \rightarrow x_3)$ و $(\neg x_3 \rightarrow \neg x_1)$ تبدیل می‌شود.
  - از $(\neg x_2 \lor \neg x_3)$ به $(x_2 \rightarrow \neg x_3)$ و $(x_3 \rightarrow \neg x_2)$ تبدیل می‌شود.
- شناسایی SCCها: با استفاده از الگوریتم kosaraju یا tarjan، SCCها را پیدا کنید.
- اختصاص مقادیر: اگر $x_1$ و $\neg x_1$ در یک SCC نباشند، مقادیر را بر اساس ترتیب توپولوژیکی اختصاص دهید.

### fibonacci heap

#### اثبات زمان محاسبه‌ای amortized

**تابع پتانسیل:**
\[
\Phi(H) = t(H) + 2m(H)
\]
که در آن $t(H)$ تعداد درخت‌ها و $m(H)$ تعداد گره‌های علامت‌گذاری شده است. این تابع پتانسیل برای محاسبه هزینه‌های amortized استفاده می‌شود.

**عملیات درج:**
- هزینه واقعی: $O(1)$
- تغییر در پتانسیل ($\Delta \Phi$): یک درخت جدید اضافه می‌شود، بنابراین $\Delta \Phi = 1$
- هزینه amortized: $O(1) + 1 = O(1)$

**عملیات استخراج کمینه:**
- هزینه واقعی: $O(\log n + k)$ که $k$ تعداد فرزندان ریشه است که باید به heap اصلی اضافه شوند.
- تغییر در پتانسیل ($\Delta \Phi$): تعداد درخت‌ها کاهش می‌یابد و برخی گره‌ها از حالت علامت‌گذاری خارج می‌شوند، بنابراین $\Delta \Phi = - (k - 1)$
- هزینه amortized: $O(\log n + k) - (k - 1) = O(\log n)$

**عملیات کاهش کلید:**
- هزینه واقعی: $O(1)$
- تغییر در پتانسیل ($\Delta \Phi$): یک گره ممکن است علامت‌گذاری شود یا به ریشه‌ها اضافه شود، بنابراین $\Delta \Phi = 1$
- هزینه amortized: $O(1) + 1 = O(1)$

**عملیات حذف:**
- هزینه amortized: $O(\log n)$ مشابه عملیات استخراج کمینه، زیرا حذف شامل استخراج و سپس کاهش کلید است.

### hashing

#### اثبات زمان محاسبه‌ای مورد انتظار

**عامل بار و احتمال برخورد:**
\[
\alpha = \frac{n}{m}
\]
که در آن $n$ تعداد عناصر و $m$ تعداد مکان‌های جدول هش است.

**آدرس‌دهی باز:**
- تعداد جستجوهای مورد انتظار: $\frac{1}{1 - \alpha}$ برای عامل بار $\alpha < 1$. هرچه $\alpha$ به 1 نزدیک‌تر باشد، احتمال برخورد بیشتر می‌شود.

**زنجیره‌سازی جداگانه:**
- طول زنجیره مورد انتظار: $\alpha$. در حالت متوسط، هر لیست پیوندی طول $\alpha$ خواهد داشت.
- زمان محاسبه‌ای مورد انتظار: $O(1 + \alpha)$. عملیات درج، جستجو و حذف به طور متوسط در زمان $O(1 + \alpha)$ انجام می‌شود.

**هشینگ جهانی:**
- تعداد برخوردهای مورد انتظار: $O(1)$. هشینگ جهانی توابع هش را به طور تصادفی انتخاب می‌کند تا برخوردها به حداقل برسد.

**نتیجه‌گیری:**
- زمان محاسبه‌ای مورد انتظار: $O(1)$ با یک عامل بار ثابت $\alpha$.

### minimum spanning tree (mst)

#### اثبات درستی و زمان محاسبه‌ای

**الگوریتم kruskal:**

**درستی:**
1. تمامی یال‌ها را به ترتیب غیرکاهشی وزن مرتب کنید.
2. کوچکترین یال را انتخاب کنید. بررسی کنید آیا با درخت پوشای تاکنون ساخته شده، یک چرخه تشکیل می‌دهد یا خیر با استفاده از union-find.
3. اگر چرخه تشکیل نمی‌شود، این یال را شامل کنید. تکرار کنید تا زمانی که $v-1$ یال در درخت پوشا وجود داشته باشد.

**زمان محاسبه‌ای:**
- مرتب‌سازی یال‌ها: $O(e \log e)$.
- عملیات union-find: $O(e \log v)$ با استفاده از فشرده‌سازی مسیر و union by rank.

**الگوریتم prim:**

**درستی:**
1. از یک رأس شروع کنید و درخت پوشا را به صورت حریصانه با افزودن کوچکترین یال وزن از درخت به یک رأس که در درخت نیست، گسترش دهید.
2. تکرار کنید تا تمامی رأس‌ها شامل شوند.

**زمان محاسبه‌ای:**
- با استفاده از یک صف اولویت (heap دودویی): $O(e \log v)$

### segment tree

#### اثبات زمان ساخت و عملیات پرس و جو

**ساخت:**
- زمان محاسبه‌ای: $O(n \log n)$. برای هر سطح از درخت که $O(\log n)$ سطح است، ما $O(n)$ گره داریم.

**عملیات پرس و جو:**
- زمان محاسبه‌ای: $O(\log n)$. هر پرس و جو از ریشه شروع می‌شود و تا پایین درخت پیمایش می‌کند.

**عملیات بروزرسانی:**
- زمان محاسبه‌ای: $O(\log n)$. هر بروزرسانی نیاز به پیمایش از ریشه تا برگ دارد.

**اثبات:**
1. ارتفاع درخت قطعه‌ای $\log n$ است.
2. هر عملیات پرس و جو/بروزرسانی از $\log n$ گره عبور می‌کند.

**نتیجه‌گیری:**
- ساخت درخت قطعه‌ای: $O(n \log n)$
- پرس و جو محدوده: $O(\log n)$
- بروزرسانی نقطه‌ای: $O(\log n)$

### skip list

#### اثبات زمان محاسبه‌ای متوسط

**ارتفاع مورد انتظار:**
- هر سطح در یک skip list تقریباً نصف گره‌های سطح زیرین خود را داراست.
- ارتفاع مورد انتظار $h$ برای skip list برابر $O(\log n)$ است.

**عملیات جستجو:**
- زمان محاسبه‌ای مورد انتظار: $O(\log n)$.
- هر سطح فضای جستجو را به نصف کاهش می‌دهد، مشابه با جستجوی دودویی.

**عملیات درج/حذف:**
- زمان محاسبه‌ای مورد انتظار: $O(\log n)$.
- هر عملیات درج/حذف شامل جستجوی مکان و بروزرسانی اشاره‌گرها در سطوح مختلف است.

**نتیجه‌گیری:**
- ارتفاع مورد انتظار: $O(\log n)$.
- جستجو: $O(\log n)$.
- درج/حذف: $O(\log n)$.

### traveling salesman problem (tsp)

#### اثبات الگوریتم‌های تقریبی

**heuristic نزدیک‌ترین همسایه:**
- از یک رأس شروع کنید، به ترتیب نزدیک‌ترین رأس بازدید نشده را بازدید کنید تا زمانی که تمامی رأس‌ها بازدید شوند.
- نسبت تقریبی: می‌تواند در بدترین حالت $O(\log n)$ باشد.

**الگوریتم christofides:**
- ساخت mst، یافتن یک تطبیق کامل کمینه وزن در زیرنمودار رئوس با درجه فرد، و تشکیل یک مدار اویلری.
- نسبت تقریبی: $\frac{3}{2}$.

### trie

#### اثبات پیچیدگی‌های فضا و زمان

**عملیات درج:**
- زمان محاسبه‌ای: $O(L)$ که در آن $L$ طول رشته است.

**عملیات جستجو:**
- زمان محاسبه‌ای: $O(L)$ که در آن $L$ طول رشته است.

**پیچیدگی فضا:**
- پیچیدگی فضا: $O(N \cdot L)$ که در آن $N$ تعداد رشته‌ها و $L$ طول متوسط است.

**اثبات:**
1. هر کاراکتر یک رشته در یک گره ذخیره می‌شود.
2. هر گره حداکثر 26 فرزند دارد (برای حروف کوچک انگلیسی).

### نتیجه‌گیری

این اثبات‌های دقیق پشتیبانی ریاضی برای زمان و پیچیدگی‌های فضایی ساختارهای داده و الگوریتم‌های مختلف فراهم می‌کنند، و اطمینان حاصل می‌کنند که درک واضحی از ویژگی‌های عملکردی آن‌ها به دست می‌آید.
